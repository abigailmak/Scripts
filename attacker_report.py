#!/usr/bin/env python3
#=====================================
# Abigail Mak
# Date: 10/29/2025
# Course: NSSA221 Systems Administration I
#
# Description:
#   Parse a provided syslog file and produce an "Attacker Report" showing
#   IP addresses that have 10 or more failed SSH login attempts, the
#   count of attempts, and the country of origin (using geoip.geolite2).
#
# Requirements satisfied:
#   - Shebang present
#   - Script clears the terminal
#   - Uses regex for IP extraction
#   - Shows headers, count, IP, country
#   - Shows current date
#   - Filters IPs with >= 10 failed attempts
#   - Sorted ascending by count
#   - Uses geoip/geolite2 to resolve country
#   - Sufficient comments + Pythonic style
#   - Safe error handling for missing files or missing geoip data
#======================================

import re
import os
import sys
from datetime import datetime
from collections import Counter, OrderedDict

# GeoIP import
try:
    from geoip import geolite2
except Exception as e:
    geolite2 = None  #lets handle this a lil later

# CONFIGURATION
# I'm ngl i lowkey hate the way the freaking word_word format looks but im warming up to it
DEFAULT_LOG_PATHS = [
    "/home/student/syslog.log",
    "./syslog.log",
]

MIN_FAILED_ATTEMPTS = 10  # if at first you don't succeed try again, until you hit 10 jeez thats too much

# Clear the terminal screen, we love a clear terminal
def clear_terminal():
    try:
        os.system("clear")
    except Exception:
        print("\n" * 100)

# Compile regex to capture IPv4 addresses from "Failed password for ... from <IP>"
# This also covers lines like:
#   "sshd[...] Failed password for root from 1.2.3.4 port 12345 ssh2"
# we gotta cover all the bases
# some might say...
# we gotta cover our butts

IP_PATTERN = re.compile(
    r"Failed password for (?:invalid user\s+)?\S+\s+from\s+(\b(?:\d{1,3}\.){3}\d{1,3}\b)",
    flags=re.IGNORECASE
)


def find_log_file():
    # Return the first existing log file path from DEFAULT_LOG_PATHS or raise.
    for path in DEFAULT_LOG_PATHS:
        if os.path.isfile(path):
            return path
    raise FileNotFoundError(
        "Could not find syslog.log in expected locations. "
        f"Checked: {', '.join(DEFAULT_LOG_PATHS)}"
    )


def extract_failed_ips(log_text):
    # Return list of IPv4 addresses found in failed-authentication messages.
    return IP_PATTERN.findall(log_text)


def count_ips(ip_list):
    # Return a Counter mapping IP -> count 
    return Counter(ip_list)


def country_for_ip(ip):
    # Return the ISO country code (or 'Unknown') for an IP using geolite2.
    if geolite2 is None:
        return "Unknown"
    try:
        match = geolite2.lookup(ip)
        if match and getattr(match, "country", None):
            # match.country is usually the country code (e.g., 'US')
            return match.country
    except Exception:
        pass
    return "Unknown"


def print_report(rows):
    # Nicely print the report to stdout.
    # Header with date
    # We need nice looking stuff here guys
    title_date = datetime.now().strftime("%B %d, %Y")
    print(f"\033[1;32mAttacker Report â€“ {title_date}\033[0m\n")

    # Column headers
    col_count = "COUNT"
    col_ip = "IP ADDRESS"
    col_country = "COUNTRY"
    print(f"{col_count:<8}  {col_ip:<18}  {col_country}")
    print("-" * 46)

    # Rows
    if not rows:
        print("No IP addresses with", MIN_FAILED_ATTEMPTS, "or more failed attempts found.")
    else:
        for count, ip, country in rows:
            print(f"{count:<8}  {ip:<18}  {country}")

    print("-" * 46)
    print(f"Total flagged IPs: {len(rows)}")
    print("Report generated by attacker_report.py")


def main():
    # Clear screen per rubric
    clear_terminal()

    # Find log file
    try:
        log_path = find_log_file()
    except FileNotFoundError as e:
        print("Error:", e, file=sys.stderr)
        sys.exit(2)

    # Read log file
    try:
        with open(log_path, "r", encoding="utf-8", errors="ignore") as fh:
            log_text = fh.read()
    except Exception as e:
        print(f"Error reading log file ({log_path}): {e}", file=sys.stderr)
        sys.exit(3)

    # Extract IPs with regex
    ip_list = extract_failed_ips(log_text)

    # Count failures per IP
    counts = count_ips(ip_list)

    # Filter to MIN_FAILED_ATTEMPTS or greater
    attackers = {ip: cnt for ip, cnt in counts.items() if cnt >= MIN_FAILED_ATTEMPTS}

    # Sort by count ascending (rubric: "Count is sorted in ascending order.")
    sorted_attackers = sorted(attackers.items(), key=lambda pair: pair[1])

    # Prepare rows (resolve countries)
    rows = format_report_rows(sorted_attackers)

    # Print report
    print_report(rows)


if __name__ == "__main__":
    main()
                                                                                                                                                                                                                                                                                                                                                                          176,10        Bot

